(ns instilled.cljdbc
  (:require
    [instilled.cljdbc.core  :refer :all])
  (:import
    [java.sql
     PreparedStatement
     Connection]
    [javax.sql
     DataSource]))

(defn make-datasource
  "Make a datasource. Use `make-default-transaction-strategy` if
   not provided through as `:transaction-strategy` in `options`."
  [spec {:keys [transaction-strategy] :as options}]
  ;;(load-dialect spec)
  (cond
    (and (string? spec)
         (connection-pool-type options))
    (CljdbcProxyDataSource.
      (make-pooled-datasource spec options)
      nil
      nil)

    (instance? javax.sql.DataSource spec)
    (CljdbcProxyDataSource.
      spec
      nil
      nil)

    (string? spec)
    (CljdbcProxyStringDataSource.
      spec
      nil
      nil)

    :else
    (throw
      (IllegalStateException.
        (str "Unsupported `spec` provided to `make-datasource`!")))))

(defmacro with-connection
  "Evaluates body in the context of an active connection to the database.
   A new transaction is automatically spawned.

   An open connection should be used by only one thread concurrently.

   (with-connection [conn conn]
     ... con-db ...)"
  [binding & body-and-or-options]
  (let [conn-var (first binding)
        [options body] (if (map? (first body-and-or-options))
                         [(first body-and-or-options) (rest body-and-or-options)]
                         [{} body-and-or-options])]
    `(let [spec# ~(second binding)
           ~conn-var (-> spec#
                         (get-connection ~options)
                         (bind-transaction ~options))]
       (with-open [conn# (lift-connection ~conn-var)]
         (do-transactionally
           ~conn-var ~options
           (fn [] ~@body))))))

(defmacro with-transaction
  "Transactionally executes body.

   `with-transaction` does not create a new connection & transaction scope
   unless `{:requires-new true}` is provided in `options`.

   See also `with-connection`."
  [binding & body-and-or-options]
  (let [conn-var (first binding)
        [options body] (if (map? (first body-and-or-options))
                         [(first body-and-or-options) (rest body-and-or-options)]
                         [{} body-and-or-options])]
    `(let [~conn-var ~(second binding)]
       (do-transactionally
         ~conn-var ~options
         (fn [] ~@body)))))

(defn prepare-query
  "Query the database given `query-spec`. Return the open `ResultSet`.
   Usually you would use `query` fn."
  [^Connection conn query-spec & [params options]]
  (let [query-spec (update query-spec :options merge options)
        stmt (create-prepared-statement conn query-spec)]
    (set-prepared-statement-params! stmt query-spec params)))

(defn query
  "Query the database given `query-spec`."
  [conn query-spec & [params options]]
  (with-open [stmt (prepare-query (lift-connection conn) query-spec params options)
              rs   (.executeQuery stmt)]
    (doall (result-set-seq rs {}))))

(defn execute!
  "Run an DML query (insert, update, delete) against the dabase.
   May return auto-increment keys."
  [conn query-spec & [params {:keys [returning] :as options}]]
  (let [query-spec (update query-spec :options merge options)]
    (with-open
      [^PreparedStatement stmt (create-prepared-statement
                                 (lift-connection conn) query-spec)]
      (if (and (sequential? params)
               (coll? (first params)))
        ;; multiple "rows" - either insert batched or iterate over each
        ;; row
        ;; TODO: may strategy depend on driver?
        (do
          (if (batched? query-spec)
            (do
              (doseq [params params]
                (set-prepared-statement-params! stmt query-spec params)
                (.addBatch stmt))
              (let [cnt (into [] (.executeBatch stmt))]
                (collect-result stmt query-spec cnt)))
            (throw (UnsupportedOperationException. "Currently not implemented!"))))
        ;; either no data or a single "row"
        (do
          (set-prepared-statement-params! stmt query-spec params)
          (let [cnt (.executeUpdate stmt)]
            (collect-result stmt query-spec cnt)))))))

(defn insert!
  "Insert record(s) into the database. If `(= true (:returning options))`
   the inserted autogenerated key(s) will be returned (if supported by the
   underlying driver)."
  [conn query-spec & [params {:keys [returning] :as options}]]
  (execute! conn query-spec params options))

(defn update!
  "Update record(s) in the database. Return the affected rows."
  [conn query-spec & [params options]]
  (execute! conn query-spec params options))

(defn delete!
  "Delete record(s) in the database."
  [conn query-spec & [params options]]
  (execute! conn query-spec params options))
