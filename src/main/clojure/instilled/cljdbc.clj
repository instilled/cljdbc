(ns instilled.cljdbc
  (:require
    [clojure.java.jdbc     :as jdbc])
  (:import
    [java.sql
     PreparedStatement]))

;; TODO: remove dependency to clojure.java.jdbc

(defrecord QuerySpec [sql params-idx])

(defn parse-statement
  "Parse a possibly parametrized sql-string into `QuerySpec`. Both, named and sequential params are supported.
   Params must be prefixed with `:`, i.e. positional params `:?` and named params `:named-param`."
  [sql-str]
  (let [m (re-matcher #":(\w+-\w+|\w+|\?)" sql-str)]
    (loop [i 1 params-idx nil]
      (if-let [f (and (.find m) (.group m 1))]
        (recur
          (inc i)
          (update
            params-idx
            (keyword f)
            #(if (vector? %1) (conj %1 %2) [%2])
            i))
        (QuerySpec. (.replaceAll m "?") params-idx)))))

(defn set-prepared-statement-params!
  "Set the `stmnt`'s `params` based on `query-spec`."
  [^PreparedStatement stmnt query-spec params]
  (doseq [[k ixs] (:params-idx query-spec) ix ixs]
    (jdbc/set-parameter (get params k) stmnt ix))
  stmnt)

(defn create-prepared-statement
  "Create prepared statement. Currently defers to `clojure.java.jdbc/prepare-statement`."
  [conn query-spec options]
  #_(.prepareStatement
      (jdbc/db-find-connection conn)
      (:sql query-spec)
      (int-array 1 [0]))
  (jdbc/prepare-statement
    (jdbc/db-find-connection conn)
    (:sql query-spec)
    (or options {})))

(defn collect-result
  "Either zttempt to fetch autoincrement keys (if `return-keys == true` and
   supported by driver) or err to `cnt`."
  [^PreparedStatement stmnt cnt {:keys [return-keys] :as options}]
  (let [;; may not be supported by all vendors
        ret-ks  (^{:once true} fn* [stmnt alt-ret]
                 (try
                   (let [rs (.getGeneratedKeys stmnt)]
                     (doall (jdbc/result-set-seq rs)))
                   (catch Exception _ alt-ret)))
        ret-cnt (^{:once true} fn* [stmnt alt-ret] alt-ret)]
    ((if return-keys ret-ks ret-cnt) stmnt cnt)))


;; #######################################
;; Public API

(defn query
  "Query the database given `query-spec`."
  [conn query-spec & [params options]]
  (jdbc/with-db-connection [conn conn]
    (let [stmnt (create-prepared-statement conn query-spec options)]
      (try
        (let [stmnt (set-prepared-statement-params! stmnt query-spec params)]
          (jdbc/query conn [stmnt] (or options {})))
        (finally
          (.close stmnt))))))

(defn execute!
  "Insert a single record into the database, returing the inserted key (if supported)."
  [conn query-spec & [params {:keys [return-keys] :as options}]]
  (jdbc/with-db-connection [conn conn]
    (let [^PreparedStatement stmnt (create-prepared-statement conn query-spec options)]
      (try
        (if (vector? params)
          (do
            (doseq [params params]
              (set-prepared-statement-params! stmnt query-spec params)
              (.addBatch stmnt))
            (let [cnt (into [] (.executeBatch stmnt))]
              (collect-result stmnt cnt options)))
          (do
            (set-prepared-statement-params! stmnt query-spec params)
            (let [cnt (.executeUpdate stmnt)]
              (collect-result stmnt cnt options))))
        (finally
          (.close stmnt))))))

(defn insert!
  "Insert record(s) into the database. If `(= true (:return-keys options))` the inserted
   autogenerated key(s) will be returned (if supported by the underlying driver)."
  [conn query-spec & [params {:keys [return-keys] :as options}]]
  (execute! conn query-spec params options))

(defn update!
  "Update record(s) in the database. Return the affected rows."
  [conn query-spec & [params options]]
  ;; TODO: is dissoc the really ok?
  (execute! conn query-spec params (dissoc options :return-keys)))

(defn delete!
  "Delete record(s) in the database."
  [conn query-spec & [params options]]
  (execute! conn query-spec params (dissoc options :return-keys)))
