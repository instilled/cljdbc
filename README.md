# Cljdbc [![Build Status][badge]][build]

This is alpha software! Basic db ops should work fairly well. Transaction
support is still under development but may work as well. Expect some breaking
API changes before a first release.

An opinonated JDBC wrapper for clojure inspired by `clojure.java.jdbc` and
funcool's `clojure.jdbc`. It uses `PreparedStatement`s for all of the
queries and adds further capabilities for named parameters as does `yesql`.
Declaring named & positional parameters uses Spring notation (colon).

Contributions & bugfixes are much appreciated!

[![Clojars Project](https://img.shields.io/clojars/v/cljdbc.svg)](https://clojars.org/cljdbc)


## Features & WIP

* Named & positional parameters as well as usual `?` supported
* `java.sql.PreparedStatement` everywhere (proven by other implementations
  building on jdbc, e.g. hibernate)
* [wip] Full transaction support based on savepoints (thus only compatible
  with drivers supporting savegoints [add non-savepoint based
  transaction manager?]
* Connection pools for Hikari [wip: Tomcat JDBC, C3P0]
* [wip] Multi vendor support:
  * unified autogenerated pks retrieval (currently mysql, postgres, oracle [with ojdbc7])
  * type conversion
* [tbd] DBUnit integration
* [tbd] DDL statements
* [tbd] Auto-select queries based on vendor (to support multi-vendor code)
* [tbd] Support Spring's transaction manager & JDBC Template bindings
* [tbd] Investigate `clojure.spec` support?

### Vendor support

* MySQL -> ok
* Oracle -> ok
* Postgres -> ok
* (DB2, MSSQL, ...) -> undecided


# Rationale

Why yet another clojure jdbc wrapper?

TBD

Compares to and build on:
* clojure.java.jdbc
* funcool java.jdbc
* hibernate

Missing features:
* simple & standardized API
* named params
* connection pool
* transaction hooks
* savepoints
* unified vendor support (e.g. autogenerated pks) when
  working with code targeting multiple vendors


# Quick Start

To get started create a datasource. `make-datasource` takes
either a

* jdbc url
* pre-configured `java.sql.DataSource`
* string pointing to some jndi datasource (prefix the location with
  `jndi:`)

Unlike `clojure.java.jdbc` cljdbc does not support other forms of
creating a connection/datasource, e.g. through a map. All
connection details must thus be provided in the jdbc-url.

```clojure
(require [instilled.cljdbc :as jdbc])

;; The preferred way of connecting to the database is to use a connection pool.
;; Currently only hikari is supported. Others (C3P0, Tomcat CP) are WIP.
;; Requires hikari dependency be on the classpath, throws otherwise.
(def ds
  (jdbc/make-datasource "jdbc:mysql://localhost:3306/cljdbc?username=cljdbc?password=cljdbc"
   {:hikari {}})

;; This one is unpooled and uses java.sql.DriverManager/getConnection each time
;; a connection is requested.
(def ds-unpooled
  (jdbc/make-datasource "jdbc:mysql://localhost:3306/cljdbc?username=cljdbc?password=cljdbc"))
```

See `instilled.cljdbc.cp.{hikari,...}` for options supported by a
connection pool implementation.

A connection can be obtained with `with-connection` macro.

```clojure
(jdbc/with-connection [conn ds]
  (let [result (jdbc/query conn my-query {:mass 100})]
    ;; do something with `result`
  ))
```

`with-connection-binding` may also be used to establish a connection.
It binds to a dynamic var. This may be useful if passing the connection
around as parameter is not be desired.

```clojure
(def ^:dynamic *my-global-var*)

(jdbc/with-connection-binding [*my-global-var* ds]
  (let [result (jdbc/query conn my-query {:mass 100})]
    ;; do something with `result`
  ))
```

## Query

```clojure
;; with named params
(def my-query (jdbc/parse-statement "select mass from planet where mass > :mass"))
(jdbc/with-connection [conn ds]
  (let [result (jdbc/query conn my-query {:mass 100})]
    ;; do something with `result`
  ))

;; with positional params
(def my-query (jdbc/parse-statement "select mass from planet where mass > :? and system = :?"))
(jdbc/with-connection [conn ds]
  (let [result (jdbc/query conn my-query {:? [100 "Solar System"]})]
    ;; do something with `result`
    ))

;; or classic positional
(def my-query (jdbc/parse-statement "select mass from planet where mass > ? and system = ?"))
(jdbc/with-connection [conn ds]
  (let [result (jdbc/query conn my-query [100 "Solar System"])]
    ;; do something with `result`
    ))
```


## Insert

```clojure
(def my-insert (jdbc/parse-statement "insert into planet (system, name, mass) values (:system,:name,:mass)"
                 ;; If you want to retrieve the autogenerated primary key, use returning
                 {:returning ["id"]}))
(with-connection [conn ds]
  ;; The insert will only be performed in batch mode if `batched?`
  ;; is set to true. This may also be added to the `parse-statement`
  ;; method.
  (let [result (jdbc/insert! conn my-insert [{:system "Solar System" :name "Earth" :mass 3.47}]
                 {:batched? true})]
    ;; result contains auto-generated pks (if :returning clause provided in statement)
    ))
```

Delete and update queries are analogous.

## Transactions

TBD

```clojure
(with-transaction [conn conn] <options>
   ...)
```

## DDL

TBD


# Hacking

TBD

Running the repl will add `src/test/{clojure,resources}` to the classpath. If you use `cider`
you may want to add cider deps to the classpath as well. Start the repl with

    boot [cider] repl

where `[cider]` assumes you've got a boot cider tasks defined somewhere, e.g. in
`~/.boot/profile.boot`.


## Running tests

Tests can be run with

    boot test

For integration tests make sure docker containers are running (see [Docker Database Setup](#docker-database-setup) below for details how to spawn
docker boxes) then type

    boot oracle test
    boot mysql test

## Docker Database Setup

It is assumed that docker agent runs natively on the machine, i.e.
not through anything like `boot2docker`.

## Oracle

```sh
(cd src/docker/docker-oracle && docker build -t cljdbc-oracle .)
docker run -d -p 49161:1521 cljdbc-oracle
```

You'll now be able to connect to it with

```sh
user: cljdbc
password: cljdbc
host: localhost:49161
```

## MySQL

```sh
(cd src/docker/docker-mysql && docker build -t cljdbc-mysql .)
docker run -e MYSQL_ROOT_PASSWORD=cljdbc-root -d -p 3306:3306 cljdbc-mysql
```

You can connect to it with

```sh
user: cljdbc
password: cljdbc
host: localhost:49161
```

## Postgres

```sh
(cd src/docker/docker-postgres && docker build -t cljdbc-postgres .)
docker run -e POSTGRES_PASSWORD=cljdbc-root -d -p 5432:5432 cljdbc-postgres
```

You can connect to it with

```sh
user: cljdbc
password: cljdbc
host: localhost:5432
```


# License

Copyright (C) 2016 Fabio Bernasconi

Distributed under the Eclipse Public License, the same as Clojure.


[badge]: https://travis-ci.org/instilled/cljdbc.svg?branch=master
[build]: https://travis-ci.org/instilled/cljdbc
