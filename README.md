# Cljdbc

This is alpha software! Basic db ops should work fairly well. Transaction
support is still under development but may work as well. Expect some breaking
API changes before a first release.

An opinonated JDBC wrapper for clojure inspired by `clojure.java.jdbc` and
funcool's `clojure.jdbc`. It uses `PreparedStatement`s for most of the
queries and adds further capabilities for named parameters as does `yesql`.
Declaring named & positional parameters is done as in Spring (colon).

Contributions & bugfixes are of course much appreciated!


## Features & WIP

* Named & positional parameters
* `java.sql.PreparedStatement` everywhere (prooven by other implementations
  building on jdbc, e.g. hibernate)
* [wip] Full transaction support based on savepoints (does not support
  transactions on dialects that don't support savepoints [yet])
* Connection pools for Hikari [wip: Tomcat JDBC, C3P0]
* [wip] Multi dialect support:
  * unified autogenerated pks retrieval (currently mysql, oracle [with ojdbc7])
  * type conversion
* [tbd] DBUnit integration
* [tbd] DDL statements
* [tbd] Auto-select queries based on dialect (to support multi-dialect code)
* [tbd] Support Spring's transaction manager & JDBC Template bindings

### Dialect support roadmap

* MySQL
* Oracle
* Postgres
* others undecided (DB2, MSSQL, ...)


# Rationale

Why another clojure jdbc wrapper?

TBD

Compare to and build on:
* clojure.java.jdbc
* funcool java.jdbc
* hibernate

Missing features:
* simple & standardized API
* named params
* transaction hooks
* savepoints
* unified multi-dialect support (e.g. autogenerated pks)


# Quick Start

To get started create a datasource.

    (require [instilled.cljdbc :as jdbc])
    (def ds (jdbc/make-datasource
                "jdbc:mysql://localhost:3306/cljdbc?username=cljdbc?password=cljdbc"
                ;; Enable hikari connection pool with default options.
                ;; Expects hikari dependency on the classpath. Throws
                ;; otherwise.
                {:hikari {}}))

## Query

    ;; with named params
    (def my-query (jdbc/parse-statement "select mass from planet where mass > :mass"))
    (jdbc/with-connection [conn ds]
      (let [result (jdbc/query conn my-query {:mass 100})]
        ;; do something with `result`
      ))

    ;; with positional params
    (def my-query (jdbc/parse-statement "select mass from planet where mass > :? and system = :?"))
    (jdbc/with-connection [conn ds]
      (let [result (jdbc/query conn my-query {:? [100 "Solar System"]})]
        ;; do something with `result`
        ))

## Insert

    (def my-insert (jdbc/parse-statement "insert into planet (system, name, mass) values (:system,:name,:mass)"
                     ;; Enable pk retrieval for newly inserted rows by telling which cols to retrieve.
                     ;; Omit to return default driver value
                     {:returning ["id"]}"))
    (with-connection [conn ds]
      (let [result (jdbc/insert! conn my-insert [{:system "Solar System" :name "Earth" :mass 3.47}])]
        ;; result contains auto-generated pks (if :returning clause provided in statement)
        ))

Delete and update queries are analogous.

## Transactions

TBD

    (with-transaction [conn conn] <options>
       ...)

## DDL

TBD


# Hacking

TBD

Running the repl will add `src/test/{clojure,resources}` to the classpath. If you use `cider`
you may want to add cider deps to the classpath as well. Start the repl with

    boot [cider] repl

where `[cider]` assumes you've got a boot cider tasks defined somewhere, e.g. in
`~/.boot/profile.boot`.


## Running tests

Tests can be run with

    boot test

For integration tests make sure docker containers are running (see [Docker Database Setup](#docker-database-setup) below for details how to spawn
docker boxes) then type

    boot oracle test
    boot mysql test

## Docker Database Setup

It is assumed that docker agent runs natively on the machine, i.e.
not through anything like `boot2docker`.

For oracle type:   then type

    (cd src/docker/docker-oracle && docker build -t cljdbc-oracle .)
    docker run -d -p 49161:1521 cljdbc-oracle

You'll now be able to connect to it with

    user: cljdbc
    password: cljdbc
    host: localhost:49161

Things are similar for mysql. Type:

    (cd src/docker/docker-mysql && docker build -t cljdbc-mysql .)
    docker run -e MYSQL_ROOT_PASSWORD=cljdbc-root -d -p 3306:3306 cljdbc-mysql

You can connect to it with

    user: cljdbc
    password: cljdbc
    host: localhost:49161


# License

Copyright (C) 2016 Fabio Bernasconi

Distributed under the Eclipse Public License, the same as Clojure.
