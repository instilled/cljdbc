# Cljdbc

An opinonated JDBC wrapper for clojure inspired by `clojure.java.jdbc` and
funcool's `clojure.jdbc`. It uses `PreparedStatement`s for most of the
queries and adds further capabilities for named parameters as does `yesql`.
Named & positional parameters syntax is aliged to Spring's syntax.
It aims at simplicity and easy of use and shuold "just work".

Some things are still WIP but other than that query & dml, transaction support
and connection pools work well.

Contributions & bugfixes are much appreciated!


## Features & WIP

* Named & positional parameters
* `java.sql.PreparedStatement` everywhere (prooven by other implementations
  building on jdbc, e.g. hibernate)
* Full transaction support based on savepoints (does not support transactions
  on dialects that don't support savepoints [yet])
* Connection pools for Hikari [wip: Tomcat JDBC, C3P0]
* [wip] Multi dialect support:
  * unified autogenerated pks retrieval (currently mysql, oracle [with ojdbc7])
  * type conversion
* [tbd] DBUnit integration
* [tbd] DDL statements
* [tbd] Auto-select queries based on dialect (to support multi-dialect code)
* [tbd] Support Spring's transaction manager & JDBC Template bindings


# Rationale

Why another clojure jdbc wrapper?

Compare to and build on:
* clojure.java.jdbc
* funcool java.jdbc
* hibernate

Missing features:
* simple & standardized API
* named params
* transaction hooks
* savepoints
* unified multi-dialect support (e.g. autogenerated pks)


# Quick Start

To get started create a connection

    (require [instilled.cljdbc :as jdbc])

    (def ds (jdbc/make-datasource
                "jdbc:mysql://localhost:3306/cljdbc?username=cljdbc?password=cljdbc"
                ;; Enable hikari connection pool with default options.
                ;; Expects hikari dependency on the classpath. Throws
                ;; otherwise.
                {:hikari {}}))

## Query

    ;; with named params
    (def my-query (jdbc/parse-statement "select mass from planet where mass > :mass"))
    (jdbc/with-connection [conn ds]
      (let [result (jdbc/query conn my-query {:mass 100})]
        ;; do something with `result`
      ))

    ;; with positional params
    (def my-query (jdbc/parse-statement "select mass from planet where mass > :? and system = :?"))
    (jdbc/with-connection [conn ds]
      (let [result (jdbc/query conn my-query {:? [100 "Solar System"]})]
        ;; do something with `result`
        ))

## Insert

    (def my-insert (jdbc/parse-statement "insert into planet (system, name, mass) values (:system,:name,:mass)"
                     ;; Enable pk retrieval for newly inserted rows by telling which cols to retrieve.
                     ;; Omit to return default driver value
                     {:returning ["id"]}"))
    (with-connection [conn ds]
      (let [result (jdbc/insert! conn my-insert [{:system "Solar System" :name "Earth" :mass 3.47}])]
        ;; result contains auto-generated pks (if :returning clause provided in statement)
        ))

Delete and update queries are analogous.

## Transactions

TBD

## DDL

TBD


# Hacking

TBD

Running the repl will add `src/test/{clojure,resources}` to the classpath. If you use `cider`
you may want to add cider deps to the classpath as well. Start the repl with

    boot [cider] repl

where `[cider]` assumes you've got a boot cider tasks defined somewhere, e.g. in
`~/.boot/profile.boot`.


## Running tests

Tests can be run with

    boot test

For integration tests make sure docker containers are running (see `src/docker/README.md`
for details how to do this), then type

    boot oracle test
    boot mysql test


# License

Copyright (C) 2016 Fabio Bernasconi

Distributed under the Eclipse Public License, the same as Clojure.
